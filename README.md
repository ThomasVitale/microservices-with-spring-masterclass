# Microservices with Spring Boot and Spring Cloud (Masterclass)

Learn how to use Spring Boot to implement loosely-coupled, self-contained, resilient, secure, and scalable
applications. Youâ€™ll implement the main microservices patterns like API gateway, service discovery, load balancing,
and externalized configuration leveraging the power of Spring Cloud.

## Lab 1 - Building a microservice with Spring Boot

In this lab, you'll build a blocking microservice using Spring Boot. It will expose a REST API and persist data
in a PostgreSQL database.

### 1.1 Initializing a Spring Boot project

> **Assignment**. Initialize a new Spring Boot project for Book Service including the following dependencies:
> Spring Web, Spring Data JDBC, PostgreSQL Driver, Flyway Migration. Then, configure application name
> and server port.

You can initialize a new Spring Boot project for **Book Service** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.6.0+
* _Name_: book-service
* _Packaging_: JAR
* _Java_: 17+

Choose the following dependencies:

* _Spring Web (`org.springframework.boot:spring-boot-starter-web`)_ provides the necessary libraries for building
  web applications with Spring MVC and includes Tomcat as the default embedded server.
* _Spring Data JDBC (`org.springframework.boot:spring-boot-starter-data-jdbc`)_ provides the necessary libraries
  to persist data in relational databases with JDBC using Spring Data in blocking applications.
* _PostgreSQL Driver (`org.postgresql:postgresql`)_ provides a JDBC driver that allows the application to connect
  to a PostgreSQL database.
* _Flyway Migration (`org.flywaydb:flyway-core`)_ provides the Flyway Java driver that allows the application
  to version control a database through migrations.

Once you're done, open the project in your favourite IDE. Then, replace the autogenerated `application.properties`
file with `application.yml` and configure server port and application name.

```yaml
server:
  port: 8001

spring:
  application:
    name: book-service
```

### 1.2 Domain entities and repositories with Spring Data JDBC

> **Assignment**. Implement the domain classes for Book Service: `Book` and `BookRepository`.
> Then configure the integration of Spring Boot with a PostgreSQL instance and initialize the schema
> with a Flyway migration.

The Book Service application will let you manage books for a bookshop. First of all, create a new
`domain` package in the Book Service project. Then, define a `Book` record to model the domain entity.

```java
public record Book(
    @Id
    Long id,
    String isbn,
    String title
){}
```

* `@Id` is a Spring Data annotation to mark the identifier (primary key) of the domain entity.

Next, define a `BookRepository` interface to provide access to Book data from the database.

```java
public interface BookRepository extends CrudRepository<Book,Long> {
	Optional<Book> findByIsbn(String isbn);
}
```

Then, configure a `DataSource` to integrate the application with a PostgreSQL instance.
In `src/main/resources/application.yml`, add the following configuration.

```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/bookdb
    username: admin
    password: admin
```

Finally, create a Flyway migration to initialize the schema for the `Book` domain entity.
Write the SQL query to initialize the schema in `src/main/resources/db/migration/V1__Initial_schema.sql`.

```sql
CREATE TABLE book (
    id                  BIGSERIAL PRIMARY KEY NOT NULL,
    isbn                varchar(255) UNIQUE NOT NULL,
    title               varchar(255) NOT NULL
);
```

### 1.3 Run PostgreSQL as a Docker container

> **Assignment**. Use Docker Compose to define and run a PostgreSQL container called `postgres-book`.

Create a `docker-compose.yml` file and define a service to run a PostgreSQL database for Book Service.

```yaml
version: "3.9"
services:
  postgres-book:
    image: "postgres:13.4"
    container_name: "postgres-book"
    ports:
      - 5432:5432
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=admin
      - POSTGRES_DB=bookdb
```

Then, open a Terminal window, navigate to the folder where your Docker Compose file is located,
and run this command to run PostgreSQL.

```bash
$ docker-compose up -d postgres-book
```

### 1.4 RESTful microservices with Spring Web

> **Assignment**. Implement a `BookController` class to expose a REST API to create and read books.

| Endpoint	      | Method   | Req. body  | Status | Resp. body     | Description    		   	     |
|:---------------:|:--------:|:----------:|:------:|:--------------:|:-------------------------------|
| `/books`        | `GET`    |            | 200    | Book[]         | Get all the books in the catalog. |
| `/books/{isbn}` | `GET`    |            | 200    | Book           | Get the book with the given ISBN. |
| `/books`        | `POST`   | Book       | 201    | Book           | Add a new book to the catalog. |

First, define a new `web` package. Then, create a `BookController` class inside with handlers for
GET and POST requests as described in the table above.

```java
@RestController
@RequestMapping("books")
public class BookController {

  private final BookRepository bookRepository;

  public BookController(BookRepository bookRepository) {
    this.bookRepository = bookRepository;
  }

  @GetMapping
  public Iterable<Book> getAllBooks() {
    return bookRepository.findAll();
  }

  @GetMapping("{isbn}")
  public Book getBookByIsbn(@PathVariable("isbn") String isbn) {
    return bookRepository.findByIsbn(isbn)
            .orElseThrow(() -> new BookNotFoundException(isbn));
  }

  @PostMapping
  @ResponseStatus(HttpStatus.CREATED)
  public Book addBook(@RequestBody Book book) {
    return bookRepository.save(book);
  }

}
```

The controller makes use of a few annotations:
* `@RestController` is a stereotype annotation marking a class as a Spring component and as a source of handlers
  for REST endpoints.
* `@RequestMapping` identifies the root path mapping URI for which the class provides handlers ("/books").
* `@GetMapping` maps HTTP GET requests onto the specific handler method.
* `@PostMapping` maps HTTP POST requests onto the specific handler method.
* `@ResponseStatus` returns a specific HTTP status if the request is successful.
* `@PathVariable` binds a method parameter to a URI template variable ({isbn}).
* `@RequestBody` binds a method parameter to the body of a web request.

### 1.5 Running a Spring Boot microservice

> **Assignment**. Run the Book Service application and test its behaviour.

Open a Terminal window, navigate to the root folder of the Book Service project,
and run the application with the command:

```bash
$ ./gradlew bootRun
```

You can test the application with curl or [httpie](https://httpie.io).

```bash
$ http POST :8001/books isbn="1234567890" title="The Lord of the Rings"
```

```bash
$ http :8001/books"
```

## Lab 2 - Centralized configuration with Spring Cloud Config

In this lab, you'll set up a configuration server with Spring Cloud Config and use it to provide configuration
to Spring Boot microservices.

### 2.1 Initializing a project for Config Server

> **Assignment**. Initialize a new Spring Boot project for Config Server including the following dependencies:
> Config Server. Then, configure application name and server port.

You can initialize a new Spring Boot project for **Config Server** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.6.0+
* _Name_: config-server
* _Packaging_: JAR
* _Java_: 17+

Choose the following dependencies:

* _Config Server_ provides central configuration management via Git, JDBC, Vault, or other sources.

Once you're done, open the project in your favourite IDE. Then, replace the autogenerated `application.properties`
file with `application.yml` and configure server port and application name.

```yaml
server:
  port: 8888

spring:
  application:
    name: config-server
```

### 2.2 Defining a configuration repository

> **Assignment**. Define a Git repository to host configuration data, then update the Config Server application
> to use the repository and to enable the centralized configuration feature. Finally, run the Config Server.

You can define you own configuration repository in Git or use https://github.com/ThomasVitale/config-repo directly.
Either way, configure the application to pull configuration data from the specific repository in `application.yml`.

```yaml
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/ThomasVitale/config-repo
```

Then, enable the centralized configuration feature in Spring Boot with the `@EnableConfigServer` annotation.

```java
@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
  public static void main(String[] args) {
    SpringApplication.run(ConfigServerApplication.class, args);
  }
}
```

Finally, run the Config Server application:

```bash
$ ./gradlew bootRun
```

### 2.3 Using Config Server to configure Spring Boot microservices

> **Assignment**. Update Book Service with the Spring Cloud Config Client and configure it to fetch configuration
> from the Config Server.

Open the Book Service project and add a new dependency on `org.springframework.cloud:spring-cloud-starter-config`.

```groovy
ext {
  set('springCloudVersion', "2021.0.0-RC1")
}

dependencies {
  implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'
  implementation 'org.springframework.boot:spring-boot-starter-web'
  implementation 'org.springframework.cloud:spring-cloud-starter-config'
  implementation 'org.flywaydb:flyway-core'

  runtimeOnly 'org.postgresql:postgresql'

  testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

dependencyManagement {
  imports {
    mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
  }
}
```

Then, open the `application.yml` file and configure Book Service to fetch configuration data from Config Server.

```yaml
spring:
  config:
    import: "optional:configserver:"
  cloud:
    config:
      uri: http://localhost:8888
```

Re-run the Book Service application with the command:

```bash
$ ./gradlew bootRun
```

Check the application logs and verify Book Service is correctly fetching configuration from the Config Server
(`Fetching config from server at : http://localhost:8888`).

## Lab 3 - Service discovery and load balancing with Spring Cloud Netflix Eureka

In this lab, you'll set up a service discovery server with Spring Cloud Netflix Eureka and configure
Spring Boot microservices to use it instead of using IP addresses or hostnames.

### 3.1 Initializing a project for Eureka Server

> **Assignment**. Initialize a new Spring Boot project for Eureka Server including the following dependencies:
> Eureka Server. Then, configure application name and server port.

You can initialize a new Spring Boot project for **Eureka Server** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.6.0+
* _Name_: config-server
* _Packaging_: JAR
* _Java_: 17+

Choose the following dependencies:

* _Eureka Server_ provides service discovery functionality using the Netflix Eureka project.

Once you're done, open the project in your favourite IDE. Then, replace the autogenerated `application.properties`
file with `application.yml` and configure server port and application name.

```yaml
server:
  port: 8761

spring:
  application:
    name: eureka-server
```

### 3.2 Configuring service discovery (server)

> **Assignment**. Configure Eureka in standalone mode and enable the service discovery feature.
> Finally, run the Edge Server.

First of all, enable the service discovery feature in Spring Boot with the `@EnableEurekaServer` annotation.

```java
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
  public static void main(String[] args) {
    SpringApplication.run(EurekaServerApplication.class, args);
  }
}
```

Then, configure Eureka in standalone mode in `application.yml` by disabling the client functionality trying to
synchronize the service registry with other peer Eureka servers.

```yaml
eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
```

Finally, run the Eureka Server application:

```bash
$ ./gradlew bootRun
```

### 3.3 Configuring service discovery (client)

> **Assignment**. Configure both Book Service and Config Server to use Eureka to resolve service instance names.

The first step is adding a new dependency on `org.springframework.cloud:spring-cloud-starter-netflix-eureka-client`
in both the Book Service and Config Server projects.

Then, for both applications, update the `application.yml` to configure the communicatino with the Eureka Server.

```yaml
eureka:
  client:
    serviceUrl:
      defaultZone: ${EUREKA_SERVER_URL:http://localhost:8761/eureka/}
```

Furthermore, you can update Book Service to use Eureka to resolve the Config Server URL rather than
providing an hostname+port pair.

```yaml
spring:
  config:
    import: "optional:configserver:"
  cloud:
    config:
      discovery:
        enabled: true
        service-id: config-server
      uri: http://config-server
```

When you're done, re-run both Config Server and Book Service and verify everything works correctly.

## Lab 4 - Building a reactive microservice with Spring Boot

In this lab, you'll build a reactive microservice using Spring Boot. It will expose a REST API and persist data
in a PostgreSQL database.

### 4.1 Initializing a Spring Boot project

> **Assignment**. Initialize a new Spring Boot project for Order Service including the following dependencies:
> Spring Reactive Web, Spring Data R2DBC, PostgreSQL Driver, Lombok, Eureka Discovery Client, and Config Client.
> Then, configure application name, server port, and integration with Eureka Server and Config Server.

You can initialize a new Spring Boot project for **Order Service** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.5.1+
* _Name_: book-service
* _Packaging_: JAR
* _Java_: 11+

Choose the following dependencies:

* _Spring Reactive Web (`org.springframework.boot:spring-boot-starter-webflux`)_ provides the necessary libraries for
  building web applications with Spring WebFlux and includes Netty as the default embedded server.
* _Spring Data R2DBC (`org.springframework.boot:spring-boot-starter-data-r2dbc`)_ provides the necessary libraries
  to persist data in relational databases with R2DBC using Spring Data in reactive applications.
* _PostgreSQL Driver (`io.r2dbc:r2dbc-postgresql`)_ provides an R2DBC driver that allows the application to connect
  to a PostgreSQL database reactively.
* _Lombok (`org.projectlombok:lombok`)_ is an annotation library that helps reducing boilerplate code. It's not
  required, but it'll help me showing you cleaner and more focused examples.
* _Eureka Discovery Client (`org.springframework.cloud:spring-cloud-starter-netflix-eureka-client`)_ provides
  integration with a Eureka Server.
* _Config Client (`org.springframework.cloud:spring-cloud-starter-config`)_ provides integration with a Config Server.

Once you're done, open the project in your favourite IDE. Then, replace the autogenerated `application.properties`
file with `application.yml` and configure server port and application name.

```yaml
server:
  port: 8002

spring:
  application:
    name: order-service
```

Finally, configure the integration with Eureka Server and Config Server.

```yaml
eureka:
  client:
    serviceUrl:
      defaultZone: ${EUREKA_SERVER_URL:http://localhost:8761/eureka/}
```

```yaml
spring:
  config:
    import: "optional:configserver:"
  cloud:
    config:
      discovery:
        enabled: true
        service-id: config-server
      uri: http://config-server
```

### 4.2 Domain entities and repositories with Spring Data R2DBC

> **Assignment**. Implement the domain classes for Order Service: `Order` and `OrderRepository`.
> Then configure the integration of Spring Boot with a PostgreSQL instance and initialize the schema
> using a `schema.sql` file.

The Order Service application will let you manage orders for books. First of all, create a new
`domain` package in the Order Service project. Then, define an `Order` class to model the domain entity.

```java
@Table("orders")
@Data @NoArgsConstructor
public class Order {

  @Id
  private Long id;
  private String isbn;
  private OrderStatus status;

  public Order(String isbn, OrderStatus status) {
    this.isbn = isbn;
    this.status = status;
  }
}
```

* `@Table` is a Spring Data annotation to customize the table name associated to the entity.
* `@Data` is a Lombok annotation to generate boilerplate code for the class, such as getters and setters.
* `@NoArgsConstructor` is a Lombok annotation to generate a constructor with no arguments.
* `@Id` is a Spring Data annotation to mark the identifier (primary key) of the domain entity.

The `OrderStatus` enum is defined as follows.

```java
public enum OrderStatus {
  ACCEPTED,
  REJECTED
}
```

Next, define an `OrderRepository` interface to provide access to Order data from the database.

```java
public interface OrderRepository extends ReactiveCrudRepository<Order,Long> {
}
```

Then, configure a an R2DBC data source to integrate the application with a PostgreSQL instance.
In `src/main/resources/application.yml`, add the following configuration.

```yaml
spring:
  r2dbc:
    username: admin
    password: admin
    url: r2dbc:postgresql://localhost:5433/orderdb
```

Finally, create an SQL file to initialize the schema for the `Order` domain entity.
Write the SQL query to initialize the schema in `src/main/resources/schema.sql`.

```sql
CREATE TABLE IF NOT EXISTS orders (
        id                  BIGSERIAL PRIMARY KEY NOT NULL,
        isbn                varchar(255) NOT NULL,
        status              varchar(255) NOT NULL
);
```

### 4.3 Run PostgreSQL as a Docker container

> **Assignment**. Use Docker Compose to define and run a PostgreSQL container called `postgres-order`.

Create a `docker-compose.yml` file and define a service to run a PostgreSQL database for Order Service.

```yaml
version: "3.8"
services:
  postgres-book:
    image: "postgres:latest"
    container_name: "postgres-book"
    ports:
      - 5432:5432
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=admin
      - POSTGRES_DB=bookdb
```

Then, open a Terminal window, navigate to the folder where your Docker Compose file is located,
and run PostgreSQL:

```bash
$ docker-compose up -d postgres-order
```

### 4.4 Reactive RESTful microservices with Spring Web

> **Assignment**. Implement an `OrderController` class to expose a REST API to create and read orders.
> For the moment, implement the POST handler to always create a rejected order.

| Endpoint	      | Method   | Req. body    | Status | Resp. body     | Description    		   	         |
|:---------------:|:--------:|:------------:|:------:|:--------------:|:---------------------------------|
| `/orders`       | `GET`    |              | 200    | Orders         | Get all the orders.              |
| `/orders`       | `POST`   | OrderRequest | 200    | Order          | Submit a new order.              |

First, define a new `web` package. Then, create a `OrderController` class inside with handlers for
GET and POST requests as described in the table above. For the moment, implement the POST handler
to always create a rejected order.

```java
@RestController
@RequestMapping("orders")
public class OrderController {
  private final OrderRepository orderRepository;

  public OrderController(OrderRepository orderRepository) {
    this.orderRepository = orderRepository;
  }

  @GetMapping
  public Flux<Order> getAllOrders() {
    return orderRepository.findAll();
  }

  @PostMapping
  public Mono<Order> submitOrder(@RequestBody OrderRequest orderRequest) {
    return orderRepository.save(new Order(orderRequest.getIsbn(), OrderStatus.REJECTED));
  }
}
```

The controller makes use of a few annotations:
* `@RestController` is a stereotype annotation marking a class as a Spring component and as a source of handlers
  for REST endpoints.
* `@RequestMapping` identifies the root path mapping URI for which the class provides handlers ("/orders").
* `@GetMapping` maps HTTP GET requests onto the specific handler method.
* `@PostMapping` maps HTTP POST requests onto the specific handler method.
* `@RequestBody` binds a method parameter to the body of a web request.

### 4.5 Resilient HTTP clients with Spring Boot

> **Assignment**. Define a load balanced WebClient object for Order Service to call Book Service.
> Then, update the POST handler in the OrderController class to retrieve the book being ordered from
> Book Service. If it's returned, the order is accepted. Otherwise, it's rejected.

The Spring Cloud Discovery Client leverages Eureka and Spring Cloud Load Balancer to decorate
a WebClient to resolve service instances from Eureka Server and use a client-side load balancing
strategy to round-robin among the instances (if more than one is running).

Let's start by creating a new config namespace and configure a `WebClient.Builder` bean.

```java
@Configuration
public class WebConfig {

  @Bean
  @LoadBalanced
  public WebClient.Builder webClientBuilder() {
    return WebClient.builder();
  }
}
```

Then, define a `Book` class to parse the book data retrieved by Book Service.

```bash
@Data
public class Book {
	private Long id;
	private String isbn;
	private String title;
}
```

Finally, update `OrderController` to use a `WebClient` and call Book Service to retrieve the book being ordered.
Service discovery and load balancing happen under the hood thanks to Spring Boot autoconfiguration.

Explore the utilities offered by Reactive Spring to make the integration point resilient through
timeouts, retries, and fallbacks.

```bash
@RestController
@RequestMapping("orders")
public class OrderController {
	private final OrderRepository orderRepository;
	private final WebClient webClient;

	public OrderController(OrderRepository orderRepository, WebClient.Builder webClientBuilder) {
		this.orderRepository = orderRepository;
		this.webClient = webClientBuilder.build();
	}

	@GetMapping
	public Flux<Order> getAllOrders() {
		return orderRepository.findAll();
	}

	@PostMapping
	public Mono<Order> submitOrder(@RequestBody OrderRequest orderRequest) {
		return webClient.get().uri("http://book-service/books/" + orderRequest.getIsbn())
				.retrieve()
				.bodyToMono(Book.class)
				.timeout(Duration.ofSeconds(2), Mono.empty())
				.onErrorResume(exception -> Mono.empty())
				.retryWhen(Retry.backoff(3, Duration.ofMillis(100)))
				.flatMap(book -> Mono.just(new Order(orderRequest.getIsbn(), OrderStatus.ACCEPTED)))
				.defaultIfEmpty(new Order(orderRequest.getIsbn(), OrderStatus.REJECTED))
				.flatMap(orderRepository::save);
	}
}
```

### 4.6 Service-to-service communication in Spring Boot

> **Assignment**. Run the Order Service application and test its behaviour.

Run the Order Service application with the command:

```bash
$ ./gradlew bootRun
```

You can test the application with curl or [httpie](https://httpie.io).

First, ensure Book Service is running and add a new book to the catalog.

```bash
$ http POST :8001/books isbn="1234567897" title="The Hobbit"
```

Then, submit an order for it. The book exists and Book Service replies correctly, so the order will be accepted.

```bash
$ http POST :8002/orders isbn="1234567897"
```

Finally, try stopping Book Service and submit an order again. This time, it won't be possible
to retrieve book information, but Order Service is implemented to be resilient, so it won't fail.
Instead, it will reject the order (graceful degradation of functionality).

```bash
$ http POST :8002/orders isbn="1234567897"
```
