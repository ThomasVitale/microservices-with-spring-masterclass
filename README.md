# Microservices with Spring Boot and Spring Cloud (Masterclass)

Learn how to use Spring Boot to implement loosely-coupled, self-contained, resilient, secure, and scalable
applications. Youâ€™ll implement the main microservices patterns like API gateway, service discovery, load balancing,
and externalized configuration leveraging the power of Spring Cloud.

## Lab 1 - Building a microservice with Spring Boot

In this lab, you'll build a blocking microservice using Spring Boot. It will expose a REST API and persist data
in a PostgreSQL database.

### 1.1 Initializing a Spring Boot project

> **Assignment**. Initialize a new Spring Boot project for Book Service including the following dependencies:
> Spring Web, Spring Data JDBC, PostgreSQL Driver, Flyway Migration. Then, configure application name
> and server port.

You can initialize a new Spring Boot project for **Book Service** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.6.0+
* _Name_: book-service
* _Packaging_: JAR
* _Java_: 17+

Choose the following dependencies:

* _Spring Web (`org.springframework.boot:spring-boot-starter-web`)_ provides the necessary libraries for building
  web applications with Spring MVC and includes Tomcat as the default embedded server.
* _Spring Data JDBC (`org.springframework.boot:spring-boot-starter-data-jdbc`)_ provides the necessary libraries
  to persist data in relational databases with JDBC using Spring Data in blocking applications.
* _PostgreSQL Driver (`org.postgresql:postgresql`)_ provides a JDBC driver that allows the application to connect
  to a PostgreSQL database.
* _Flyway Migration (`org.flywaydb:flyway-core`)_ provides the Flyway Java driver that allows the application
  to version control a database through migrations.

Once you're done, open the project in your favourite IDE. Then, replace the autogenerated `application.properties`
file with `application.yml` and configure server port and application name.

```yaml
server:
  port: 8001

spring:
  application:
    name: book-service
```

### 1.2 Domain entities and repositories with Spring Data JDBC

> **Assignment**. Implement the domain classes for Book Service: `Book` and `BookRepository`.
> Then configure the integration of Spring Boot with a PostgreSQL instance and initialize the schema
> with a Flyway migration.

The Book Service application will let you manage books for a bookshop. First of all, create a new
`domain` package in the Book Service project. Then, define a `Book` record to model the domain entity.

```java
public record Book(
    @Id
    Long id,
    String isbn,
    String title
){}
```

* `@Id` is a Spring Data annotation to mark the identifier (primary key) of the domain entity.

Next, define a `BookRepository` interface to provide access to Book data from the database.

```java
public interface BookRepository extends CrudRepository<Book,Long> {
	Optional<Book> findByIsbn(String isbn);
}
```

Then, configure a `DataSource` to integrate the application with a PostgreSQL instance.
In `src/main/resources/application.yml`, add the following configuration.

```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/bookdb
    username: admin
    password: admin
```

Finally, create a Flyway migration to initialize the schema for the `Book` domain entity.
Write the SQL query to initialize the schema in `src/main/resources/db/migration/V1__Initial_schema.sql`.

```sql
CREATE TABLE book (
    id                  BIGSERIAL PRIMARY KEY NOT NULL,
    isbn                varchar(255) UNIQUE NOT NULL,
    title               varchar(255) NOT NULL
);
```

### 1.3 Run PostgreSQL as a Docker container

> **Assignment**. Use Docker Compose to define and run a PostgreSQL container called `postgres-book`.

Create a `docker-compose.yml` file and define a service to run a PostgreSQL database for Book Service.

```yaml
version: "3.9"
services:
  postgres-book:
    image: "postgres:13.4"
    container_name: "postgres-book"
    ports:
      - 5432:5432
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=admin
      - POSTGRES_DB=bookdb
```

Then, open a Terminal window, navigate to the folder where your Docker Compose file is located,
and run this command to run PostgreSQL.

```bash
$ docker-compose up -d postgres-book
```

### 1.4 RESTful microservices with Spring Web

> **Assignment**. Implement a `BookController` class to expose a REST API to create and read books.

| Endpoint	      | Method   | Req. body  | Status | Resp. body     | Description    		   	     |
|:---------------:|:--------:|:----------:|:------:|:--------------:|:-------------------------------|
| `/books`        | `GET`    |            | 200    | Book[]         | Get all the books in the catalog. |
| `/books/{isbn}` | `GET`    |            | 200    | Book           | Get the book with the given ISBN. |
| `/books`        | `POST`   | Book       | 201    | Book           | Add a new book to the catalog. |

First, define a new `web` package. Then, create a `BookController` class inside with handlers for
GET and POST requests as described in the table above.

```java
@RestController
@RequestMapping("books")
public class BookController {

  private final BookRepository bookRepository;

  public BookController(BookRepository bookRepository) {
    this.bookRepository = bookRepository;
  }

  @GetMapping
  public Iterable<Book> getAllBooks() {
    return bookRepository.findAll();
  }

  @GetMapping("{isbn}")
  public Book getBookByIsbn(@PathVariable("isbn") String isbn) {
    return bookRepository.findByIsbn(isbn)
            .orElseThrow(() -> new BookNotFoundException(isbn));
  }

  @PostMapping
  @ResponseStatus(HttpStatus.CREATED)
  public Book addBook(@RequestBody Book book) {
    return bookRepository.save(book);
  }

}
```

The controller makes use of a few annotations:
* `@RestController` is a stereotype annotation marking a class as a Spring component and as a source of handlers
  for REST endpoints.
* `@RequestMapping` identifies the root path mapping URI for which the class provides handlers ("/books").
* `@GetMapping` maps HTTP GET requests onto the specific handler method.
* `@PostMapping` maps HTTP POST requests onto the specific handler method.
* `@ResponseStatus` returns a specific HTTP status if the request is successful.
* `@PathVariable` binds a method parameter to a URI template variable ({isbn}).
* `@RequestBody` binds a method parameter to the body of a web request.

### 1.5 Running a Spring Boot microservice

> **Assignment**. Run the Book Service application and test its behaviour.

Open a Terminal window, navigate to the root folder of the Book Service project,
and run the application with the command:

```bash
$ ./gradlew bootRun
```

You can test the application with curl or [httpie](https://httpie.io).

```bash
$ http POST :8001/books isbn="1234567890" title="The Lord of the Rings"
```

```bash
$ http :8001/books"
```

## Lab 2 - Centralized configuration with Spring Cloud Config

In this lab, you'll set up a configuration server with Spring Cloud Config and use it to provide configuration
to Spring Boot microservices.

### 2.1 Initializing a project for Config Server

> **Assignment**. Initialize a new Spring Boot project for Config Server including the following dependencies:
> Config Server. Then, configure application name and server port.

You can initialize a new Spring Boot project for **Config Server** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.6.0+
* _Name_: config-server
* _Packaging_: JAR
* _Java_: 17+

Choose the following dependencies:

* _Config Server_ provides central configuration management via Git, JDBC, Vault, or other sources.

Once you're done, open the project in your favourite IDE. Then, replace the autogenerated `application.properties`
file with `application.yml` and configure server port and application name.

```yaml
server:
  port: 8888

spring:
  application:
    name: config-server
```

### 2.2 Defining a configuration repository

> **Assignment**. Define a Git repository to host configuration data, then update the Config Server application
> to use the repository and to enable the centralized configuration feature. Finally, run the Config Server.

You can define you own configuration repository in Git or use https://github.com/ThomasVitale/config-repo directly.
Either way, configure the application to pull configuration data from the specific repository in `application.yml`.

```yaml
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/ThomasVitale/config-repo
```

Then, enable the centralized configuration feature in Spring Boot with the `@EnableConfigServer` annotation.

```java
@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
  public static void main(String[] args) {
    SpringApplication.run(ConfigServerApplication.class, args);
  }
}
```

Finally, run the Config Server application:

```bash
$ ./gradlew bootRun
```

### 2.3 Using Config Server to configure Spring Boot microservices

> **Assignment**. Update Book Service with the Spring Cloud Config Client and configure it to fetch configuration
> from the Config Server.

Open the Book Service project and add a new dependency on `org.springframework.cloud:spring-cloud-starter-config`.

```groovy
ext {
  set('springCloudVersion', "2021.0.0-RC1")
}

dependencies {
  implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'
  implementation 'org.springframework.boot:spring-boot-starter-web'
  implementation 'org.springframework.cloud:spring-cloud-starter-config'
  implementation 'org.flywaydb:flyway-core'

  runtimeOnly 'org.postgresql:postgresql'

  testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

dependencyManagement {
  imports {
    mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
  }
}
```

Then, open the `application.yml` file and configure Book Service to fetch configuration data from Config Server.

```yaml
spring:
  config:
    import: "optional:configserver:"
  cloud:
    config:
      uri: http://localhost:8888
```

Re-run the Book Service application with the command:

```bash
$ ./gradlew bootRun
```

Check the application logs and verify Book Service is correctly fetching configuration from the Config Server
(`Fetching config from server at : http://localhost:8888`).

## Lab 3 - Service discovery and load balancing with Spring Cloud Netflix Eureka

In this lab, you'll set up a service discovery server with Spring Cloud Netflix Eureka and configure
Spring Boot microservices to use it instead of using IP addresses or hostnames.

### 3.1 Initializing a project for Eureka Server

> **Assignment**. Initialize a new Spring Boot project for Eureka Server including the following dependencies:
> Eureka Server. Then, configure application name and server port.

You can initialize a new Spring Boot project for **Eureka Server** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.6.0+
* _Name_: config-server
* _Packaging_: JAR
* _Java_: 17+

Choose the following dependencies:

* _Eureka Server_ provides service discovery functionality using the Netflix Eureka project.

Once you're done, open the project in your favourite IDE. Then, replace the autogenerated `application.properties`
file with `application.yml` and configure server port and application name.

```yaml
server:
  port: 8761

spring:
  application:
    name: eureka-server
```

### 3.2 Configuring service discovery (server)

> **Assignment**. Configure Eureka in standalone mode and enable the service discovery feature.
> Finally, run the Edge Server.

First of all, enable the service discovery feature in Spring Boot with the `@EnableEurekaServer` annotation.

```java
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
  public static void main(String[] args) {
    SpringApplication.run(EurekaServerApplication.class, args);
  }
}
```

Then, configure Eureka in standalone mode in `application.yml` by disabling the client functionality trying to
synchronize the service registry with other peer Eureka servers.

```yaml
eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
```

Finally, run the Eureka Server application:

```bash
$ ./gradlew bootRun
```

### 3.3 Configuring service discovery (client)

> **Assignment**. Configure both Book Service and Config Server to use Eureka to resolve service instance names.

The first step is adding a new dependency on `org.springframework.cloud:spring-cloud-starter-netflix-eureka-client`
in both the Book Service and Config Server projects.

Then, for both applications, update the `application.yml` to configure the communicatino with the Eureka Server.

```yaml
eureka:
  client:
    serviceUrl:
      defaultZone: ${EUREKA_SERVER_URL:http://localhost:8761/eureka/}
```

Furthermore, you can update Book Service to use Eureka to resolve the Config Server URL rather than
providing an hostname+port pair.

```yaml
spring:
  config:
    import: "optional:configserver:"
  cloud:
    config:
      discovery:
        enabled: true
        service-id: config-server
      uri: http://config-server
```

When you're done, re-run both Config Server and Book Service and verify everything works correctly.

## Lab 4 - Building a reactive microservice with Spring Boot

In this lab, you'll build a reactive microservice using Spring Boot. It will expose a REST API and persist data
in a PostgreSQL database.

### 4.1 Initializing a Spring Boot project

> **Assignment**. Initialize a new Spring Boot project for Order Service including the following dependencies:
> Spring Reactive Web, Spring Data R2DBC, PostgreSQL Driver, Eureka Discovery Client, and Config Client.
> Then, configure application name, server port, and integration with Eureka Server and Config Server.

You can initialize a new Spring Boot project for **Order Service** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.6.0+
* _Name_: book-service
* _Packaging_: JAR
* _Java_: 17+

Choose the following dependencies:

* _Spring Reactive Web (`org.springframework.boot:spring-boot-starter-webflux`)_ provides the necessary libraries for
  building web applications with Spring WebFlux and includes Netty as the default embedded server.
* _Spring Data R2DBC (`org.springframework.boot:spring-boot-starter-data-r2dbc`)_ provides the necessary libraries
  to persist data in relational databases with R2DBC using Spring Data in reactive applications.
* _PostgreSQL Driver (`io.r2dbc:r2dbc-postgresql`)_ provides an R2DBC driver that allows the application to connect
  to a PostgreSQL database reactively.
* _Eureka Discovery Client (`org.springframework.cloud:spring-cloud-starter-netflix-eureka-client`)_ provides
  integration with a Eureka Server.
* _Config Client (`org.springframework.cloud:spring-cloud-starter-config`)_ provides integration with a Config Server.

Once you're done, open the project in your favourite IDE. Then, replace the autogenerated `application.properties`
file with `application.yml` and configure server port and application name.

```yaml
server:
  port: 8002

spring:
  application:
    name: order-service
```

Finally, configure the integration with Eureka Server and Config Server.

```yaml
eureka:
  client:
    serviceUrl:
      defaultZone: ${EUREKA_SERVER_URL:http://localhost:8761/eureka/}
```

```yaml
spring:
  config:
    import: "optional:configserver:"
  cloud:
    config:
      discovery:
        enabled: true
        service-id: config-server
      uri: http://config-server
```

### 4.2 Domain entities and repositories with Spring Data R2DBC

> **Assignment**. Implement the domain classes for Order Service: `Order` and `OrderRepository`.
> Then configure the integration of Spring Boot with a PostgreSQL instance and initialize the schema
> using a `schema.sql` file.

The Order Service application will let you manage orders for books. First of all, create a new
`domain` package in the Order Service project. Then, define an `Order` class to model the domain entity.

```java
@Table("orders")
public record Order(
  @Id
  Long id,
  String isbn,
  OrderStatus status
){}
```

* `@Table` is a Spring Data annotation to customize the table name associated to the entity.
* `@Id` is a Spring Data annotation to mark the identifier (primary key) of the domain entity.

The `OrderStatus` enum is defined as follows.

```java
public enum OrderStatus {
  ACCEPTED,
  REJECTED
}
```

Next, define an `OrderRepository` interface to provide access to Order data from the database.

```java
public interface OrderRepository extends ReactiveCrudRepository<Order,Long> {
}
```

Then, configure a an R2DBC data source to integrate the application with a PostgreSQL instance.
In `src/main/resources/application.yml`, add the following configuration.

```yaml
spring:
  r2dbc:
    username: admin
    password: admin
    url: r2dbc:postgresql://localhost:5433/orderdb
  sql:
    init:
      mode: always
```

Finally, create an SQL file to initialize the schema for the `Order` domain entity.
Write the SQL query to initialize the schema in `src/main/resources/schema.sql`.

```sql
CREATE TABLE IF NOT EXISTS orders (
        id                  BIGSERIAL PRIMARY KEY NOT NULL,
        isbn                varchar(255) NOT NULL,
        status              varchar(255) NOT NULL
);
```

### 4.3 Run PostgreSQL as a Docker container

> **Assignment**. Use Docker Compose to define and run a PostgreSQL container called `postgres-order`.

Create a `docker-compose.yml` file and define a service to run a PostgreSQL database for Order Service.

```yaml
version: "3.8"
services:
  postgres-book:
    image: "postgres:13.4"
    container_name: "postgres-book"
    ports:
      - 5432:5432
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=admin
      - POSTGRES_DB=bookdb
```

Then, open a Terminal window, navigate to the folder where your Docker Compose file is located,
and run PostgreSQL:

```bash
$ docker-compose up -d postgres-order
```

### 4.4 Reactive RESTful microservices with Spring Web

> **Assignment**. Implement an `OrderController` class to expose a REST API to create and read orders.
> For the moment, implement the POST handler to always create a rejected order.

| Endpoint	      | Method   | Req. body    | Status | Resp. body     | Description    		   	         |
|:---------------:|:--------:|:------------:|:------:|:--------------:|:---------------------------------|
| `/orders`       | `GET`    |              | 200    | Orders         | Get all the orders.              |
| `/orders`       | `POST`   | OrderRequest | 200    | Order          | Submit a new order.              |

First, define a new `web` package. Then, create a `OrderController` class inside with handlers for
GET and POST requests as described in the table above. For the moment, implement the POST handler
to always create a rejected order.

```java
@RestController
@RequestMapping("orders")
public class OrderController {
  private final OrderRepository orderRepository;

  public OrderController(OrderRepository orderRepository) {
    this.orderRepository = orderRepository;
  }

  @GetMapping
  public Flux<Order> getAllOrders() {
    return orderRepository.findAll();
  }

  @PostMapping
  public Mono<Order> submitOrder(@RequestBody OrderRequest orderRequest) {
    return orderRepository.save(new Order(null, orderRequest.getIsbn(), OrderStatus.REJECTED));
  }
}
```

The controller makes use of a few annotations:
* `@RestController` is a stereotype annotation marking a class as a Spring component and as a source of handlers
  for REST endpoints.
* `@RequestMapping` identifies the root path mapping URI for which the class provides handlers ("/orders").
* `@GetMapping` maps HTTP GET requests onto the specific handler method.
* `@PostMapping` maps HTTP POST requests onto the specific handler method.
* `@RequestBody` binds a method parameter to the body of a web request.

### 4.5 Resilient HTTP clients with Spring Boot

> **Assignment**. Define a load balanced WebClient object for Order Service to call Book Service.
> Then, update the POST handler in the OrderController class to retrieve the book being ordered from
> Book Service. If it's returned, the order is accepted. Otherwise, it's rejected.

The Spring Cloud Discovery Client leverages Eureka and Spring Cloud Load Balancer to decorate
a WebClient to resolve service instances from Eureka Server and use a client-side load balancing
strategy to round-robin among the instances (if more than one is running).

Let's start by creating a new config namespace and configure a `WebClient.Builder` bean.

```java
@Configuration
public class WebConfig {

  @Bean
  @LoadBalanced
  public WebClient.Builder webClientBuilder() {
    return WebClient.builder();
  }
}
```

Then, define a `Book` class to parse the book data retrieved by Book Service.

```bash
public record Book(
	String isbn,
	String title
){}
```

Finally, update `OrderController` to use a `WebClient` and call Book Service to retrieve the book being ordered.
Service discovery and load balancing happen under the hood thanks to Spring Boot autoconfiguration.

Explore the utilities offered by Reactive Spring to make the integration point resilient through
timeouts, retries, and fallbacks.

```java
@RestController
@RequestMapping("orders")
public class OrderController {
  private final OrderRepository orderRepository;
  private final WebClient webClient;

  public OrderController(OrderRepository orderRepository, WebClient.Builder webClientBuilder) {
    this.orderRepository = orderRepository;
    this.webClient = webClientBuilder.build();
  }

  @GetMapping
  public Flux<Order> getAllOrders() {
    return orderRepository.findAll();
  }

  @PostMapping
  public Mono<Order> submitOrder(@RequestBody OrderRequest orderRequest) {
    return webClient.get().uri("http://book-service/books/" + orderRequest.isbn())
            .retrieve()
            .bodyToMono(Book.class)
            .timeout(Duration.ofSeconds(2), Mono.empty())
            .onErrorResume(exception -> Mono.empty())
            .retryWhen(Retry.backoff(3, Duration.ofMillis(100)))
            .flatMap(book -> Mono.just(new Order(null, orderRequest.isbn(), OrderStatus.ACCEPTED)))
            .defaultIfEmpty(new Order(null, orderRequest.isbn(), OrderStatus.REJECTED))
            .flatMap(orderRepository::save);
  }
}
```

### 4.6 Service-to-service communication in Spring Boot

> **Assignment**. Run the Order Service application and test its behaviour.

Run the Order Service application with the command:

```bash
$ ./gradlew bootRun
```

You can test the application with curl or [httpie](https://httpie.io).

First, ensure Book Service is running and add a new book to the catalog.

```bash
$ http POST :8001/books isbn="1234567897" title="The Hobbit"
```

Then, submit an order for it. The book exists and Book Service replies correctly, so the order will be accepted.

```bash
$ http POST :8002/orders isbn="1234567897"
```

Finally, try stopping Book Service and submit an order again. This time, it won't be possible
to retrieve book information, but Order Service is implemented to be resilient, so it won't fail.
Instead, it will reject the order (graceful degradation of functionality).

```bash
$ http POST :8002/orders isbn="1234567897"
```

## Lab 5 - Implementing API Gateway and security

In this lab, you'll build an API gateway and secure Spring Boot microservices. You'll use Spring Cloud Gateway
and Spring Security.

### 5.1 Initializing the Edge Service project

> **Assignment**. Initialize a new Spring Boot project for Edge Service including the following dependencies:
> Gateway, OAuth2 Client, Eureka Discovery Client, and Config Client. Then, configure application name,
> server port, and integration with Eureka Server and Config Server.

You can initialize a new Spring Boot project for **Edge Service** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.6.0+
* _Name_: book-service
* _Packaging_: JAR
* _Java_: 17+

Choose the following dependencies:

* _Gateway (`org.springframework.cloud:spring-cloud-starter-gateway`)_ provides the necessary libraries for
  building web applications with Spring WebFlux and includes Netty as the default embedded server.
* _OAuth2 Client (`org.springframework.boot:spring-boot-starter-oauth2-client`)_ provides the Spring Security
  libraries to support OAuth2 and OpenID Connect for clients.
* _Eureka Discovery Client (`org.springframework.cloud:spring-cloud-starter-netflix-eureka-client`)_ provides
  integration with a Eureka Server.
* _Config Client (`org.springframework.cloud:spring-cloud-starter-config`)_ provides integration with a Config Server.

Once you're done, open the project in your favourite IDE. Then, replace the autogenerated `application.properties`
file with `application.yml` and configure server port and application name.

```yaml
server:
  port: 9000

spring:
  application:
    name: edge-service
```

Finally, configure the integration with Eureka Server and Config Server.

```yaml
eureka:
  client:
    serviceUrl:
      defaultZone: ${EUREKA_SERVER_URL:http://localhost:8761/eureka/}
```

```yaml
spring:
  config:
    import: "optional:configserver:"
  cloud:
    config:
      discovery:
        enabled: true
        service-id: config-server
      uri: http://config-server
```

### 5.2 Configuring routes in the API gateway

> **Assignment**. Configure routes in Edge Service to forward traffic to Book Service or Order Service
> based on the request path.

Routes in the API Gateway provided by Spring Cloud can be configured through a Java DSL or through
configuration properties. Let's go with the second option.

Since Eureka is already configured, the features offered by Spring Cloud Load Balancer are also enabled
and integrated with Spring Cloud Gateway. You can route requests to load-balanced URL using `lb://`
instead of `http://`.

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: book-route
          uri: lb://book-service/books
          predicates:
            - Path=/books/**
        - id: order-route
          uri: lb://order-service/orders
          predicates:
            - Path=/orders/**
```

Requests arriving to the Edge Service starting with the `/books` path will be forwarded to a Book Service instance.
Requests arriving to the Edge Service starting with the `/orders` path will be forwarded to a Order Service instance.

### 5.3 Running Keycloak as a Docker container

> **Assignment**. Run a Keycloak instance locally as a Docker container.

The Edge Service is a good place to implement cross-cutting concerns like security. Let's protect the whole
microservices architecture with OAuth2/OpenID Connect authentication using Spring Security and Keycloak.

Let's start by running Keycloak, an identity and access management solution. Update the Docker Compose file
with the following.

```yaml
keycloak:
  image: thomasvitale/keycloak-m1:15.0.1 # Use jboss/keycloak:15.0.1 on Intel processors
  container_name: "keycloak"
  volumes:
    - ./platform-config/keycloak:/opt/jboss/keycloak/imports
  environment:
    KEYCLOAK_USER: user
    KEYCLOAK_PASSWORD: password
    KEYCLOAK_IMPORT: /opt/jboss/keycloak/imports/realm-export.json
  ports:
    - 8080:8080
```

Then, create a `platform-config/keyclok` folder and copy the `realm-export.json` file into it
from here. After that, you can run Keycloak:

```bash
$ docker-compose up -d keycloak
```

Keycloak is already configured with two users: Isabelle (`isabelle/password`) and Bjorn (`bjorn/password`).
You can access the administration control on http://localhost:8080 using the credential `admin/password`.

### 5.4 Securing microservices with OAuth2 and OpenID Connect (Client)

> **Assignment**. Configure Edge Service as an OAuth2 Client using Spring Security.

You can add OAuth2/OpenID Connect authentication to Edge Server by adding a dependency on Spring Security
and configure the integration with Keycloak.

First, add a dependency on `org.springframework.boot:spring-boot-starter-oauth2-client`.

Then, update the `application.yml` file to configure OAuth2/OpenID Connect. Keycloak is already configured
to support an OAuth2 Client named `edge-service`. Let's register it in Spring Security too.

```yaml
security:
  oauth2:
    client:
      registration:
        keycloak:
          client-id: edge-service
          client-secret: polar-keycloak-secret
          scope: openid
      provider:
        keycloak:
          issuer-uri: ${KEYCLOAK_URL:http://localhost:8080}/auth/realms/PolarBookshop
```


By default, all endpoints are protected. If a user sends a request unauthenticated, they are
redirected to Keycloak to log in.

After the user authentication, Edge Service needs to forward the OAuth2 Access Token
to the downstream services in order to propagate the authenticated context. The token propagation
can be enabled through a Spring Cloud Gateway filter.

```yaml
spring:
  gateway:
    default-filters:
      - TokenRelay
```

### 5.5 Securing microservices with OAuth2 and OpenID Connect (Resource Server)

> **Assignment**. Configure Book Service and Order Service as OAuth2 Resource Servers using Spring Security.

Book Service and Order Service can be secured as OAuth2 Resource Servers, accepting an Access Token
by Edge Service and validating it against Keycloak.

In both projects, add a new dependency on `org.springframework.boot:spring-boot-starter-oauth2-resource-server`.

Then, in the `application.yml`, configure the integration with Keycloak.

```yaml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: ${KEYCLOAK_URL:http://localhost:8080}/auth/realms/PolarBookshop
```

By default, all endpoints are protected and require a valid OAuth2 Access Token.

### 5.6 Testing routing and security

> **Assignment**. Run all the microservices and test the main flows.

Re-run Edge Service, Book Service, and Order Service. Then, open the browser, and go to http://localhost:9000/books.
Spring Security will redirect you to Keycloak for authentication. Log in as Isabelle or Bjorn.
After a successfull authentication, you're redirected back to Edge Service and finally to Book Service.
If you previously added any book to the catalog, you'd see them now listed in a JSON format.
