# Microservices with Spring Boot and Spring Cloud (Masterclass)

Learn how to use Spring Boot to implement loosely-coupled, self-contained, resilient, secure, and scalable
applications. Youâ€™ll implement the main microservices patterns like API gateway, service discovery, load balancing,
and externalized configuration leveraging the power of Spring Cloud.

## Lab 1 - Building a microservice with Spring Boot

In this lab, you'll build a blocking microservice using Spring Boot. It will expose a REST API and persist data
in a PostgreSQL database.

### 1.1 Initializing a Spring Boot project

> **Assignment**. Initialize a new Spring Boot project for Book Service including the following dependencies:
> Spring Web, Spring Data JDBC, PostgreSQL Driver, Flyway Migration. Then, configure application name
> and server port.

You can initialize a new Spring Boot project for **Book Service** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.6.0+
* _Name_: book-service
* _Packaging_: JAR
* _Java_: 17+

Choose the following dependencies:

* _Spring Web (`org.springframework.boot:spring-boot-starter-web`)_ provides the necessary libraries for building
  web applications with Spring MVC and includes Tomcat as the default embedded server.
* _Spring Data JDBC (`org.springframework.boot:spring-boot-starter-data-jdbc`)_ provides the necessary libraries
  to persist data in relational databases with JDBC using Spring Data in blocking applications.
* _PostgreSQL Driver (`org.postgresql:postgresql`)_ provides a JDBC driver that allows the application to connect
  to a PostgreSQL database.
* _Flyway Migration (`org.flywaydb:flyway-core`)_ provides the Flyway Java driver that allows the application
  to version control a database through migrations.

Once you're done, open the project in your favourite IDE. Then, replace the autogenerated `application.properties`
file with `application.yml` and configure server port and application name.

```yaml
server:
  port: 8001

spring:
  application:
    name: book-service
```

### 1.2 Domain entities and repositories with Spring Data JDBC

> **Assignment**. Implement the domain classes for Book Service: `Book` and `BookRepository`.
> Then configure the integration of Spring Boot with a PostgreSQL instance and initialize the schema
> with a Flyway migration.

The Book Service application will let you manage books for a bookshop. First of all, create a new
`domain` package in the Book Service project. Then, define a `Book` record to model the domain entity.

```java
public record Book(
    @Id
    Long id,
    String isbn,
    String title
){}
```

* `@Id` is a Spring Data annotation to mark the identifier (primary key) of the domain entity.

Next, define a `BookRepository` interface to provide access to Book data from the database.

```java
public interface BookRepository extends CrudRepository<Book,Long> {
	Optional<Book> findByIsbn(String isbn);
}
```

Then, configure a `DataSource` to integrate the application with a PostgreSQL instance.
In `src/main/resources/application.yml`, add the following configuration.

```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/bookdb
    username: admin
    password: admin
```

Finally, create a Flyway migration to initialize the schema for the `Book` domain entity.
Write the SQL query to initialize the schema in `src/main/resources/db/migration/V1__Initial_schema.sql`.

```sql
CREATE TABLE book (
    id                  BIGSERIAL PRIMARY KEY NOT NULL,
    isbn                varchar(255) UNIQUE NOT NULL,
    title               varchar(255) NOT NULL
);
```

### 1.3 Run PostgreSQL as a Docker container

> **Assignment**. Use Docker Compose to define and run a PostgreSQL container called `postgres-book`.

Create a `docker-compose.yml` file and define a service to run a PostgreSQL database for Book Service.

```yaml
version: "3.9"
services:
  postgres-book:
    image: "postgres:13.4"
    container_name: "postgres-book"
    ports:
      - 5432:5432
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=admin
      - POSTGRES_DB=bookdb
```

Then, open a Terminal window, navigate to the folder where your Docker Compose file is located,
and run this command to run PostgreSQL.

```bash
$ docker-compose up -d postgres-book
```

### 1.4 RESTful microservices with Spring Web

> **Assignment**. Implement a `BookController` class to expose a REST API to create and read books.

| Endpoint	      | Method   | Req. body  | Status | Resp. body     | Description    		   	     |
|:---------------:|:--------:|:----------:|:------:|:--------------:|:-------------------------------|
| `/books`        | `GET`    |            | 200    | Book[]         | Get all the books in the catalog. |
| `/books/{isbn}` | `GET`    |            | 200    | Book           | Get the book with the given ISBN. |
| `/books`        | `POST`   | Book       | 201    | Book           | Add a new book to the catalog. |

First, define a new `web` package. Then, create a `BookController` class inside with handlers for
GET and POST requests as described in the table above.

```java
@RestController
@RequestMapping("books")
public class BookController {

  private final BookRepository bookRepository;

  public BookController(BookRepository bookRepository) {
    this.bookRepository = bookRepository;
  }

  @GetMapping
  public Iterable<Book> getAllBooks() {
    return bookRepository.findAll();
  }

  @GetMapping("{isbn}")
  public Book getBookByIsbn(@PathVariable("isbn") String isbn) {
    return bookRepository.findByIsbn(isbn)
            .orElseThrow(() -> new BookNotFoundException(isbn));
  }

  @PostMapping
  @ResponseStatus(HttpStatus.CREATED)
  public Book addBook(@RequestBody Book book) {
    return bookRepository.save(book);
  }

}
```

The controller makes use of a few annotations:
* `@RestController` is a stereotype annotation marking a class as a Spring component and as a source of handlers
  for REST endpoints.
* `@RequestMapping` identifies the root path mapping URI for which the class provides handlers ("/books").
* `@GetMapping` maps HTTP GET requests onto the specific handler method.
* `@PostMapping` maps HTTP POST requests onto the specific handler method.
* `@ResponseStatus` returns a specific HTTP status if the request is successful.
* `@PathVariable` binds a method parameter to a URI template variable ({isbn}).
* `@RequestBody` binds a method parameter to the body of a web request.

### 1.5 Running a Spring Boot microservice

> **Assignment**. Run the Book Service application and test its behaviour.

Open a Terminal window, navigate to the root folder of the Book Service project,
and run the application with the command:

```bash
$ ./gradlew bootRun
```

You can test the application with curl or [httpie](https://httpie.io).

```bash
$ http POST :8001/books isbn="1234567890" title="The Lord of the Rings"
```

```bash
$ http :8001/books"
```

## Lab 2 - Centralized configuration with Spring Cloud Config

In this lab, you'll set up a configuration server with Spring Cloud Config and use it to provide configuration
to Spring Boot microservices.

### 2.1 Initializing a project for Config Server

> **Assignment**. Initialize a new Spring Boot project for Config Server including the following dependencies:
> Config Server. Then, configure application name and server port.

You can initialize a new Spring Boot project for **Config Server** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.6.0+
* _Name_: config-server
* _Packaging_: JAR
* _Java_: 17+

Choose the following dependencies:

* _Config Server_ provides central configuration management via Git, JDBC, Vault, or other sources.

Once you're done, open the project in your favourite IDE. Then, replace the autogenerated `application.properties`
file with `application.yml` and configure server port and application name.

```yaml
server:
  port: 8888

spring:
  application:
    name: config-server
```

### 2.2 Defining a configuration repository

> **Assignment**. Define a Git repository to host configuration data, then update the Config Server application
> to use the repository and to enable the centralized configuration feature. Finally, run the Config Server.

You can define you own configuration repository in Git or use https://github.com/ThomasVitale/config-repo directly.
Either way, configure the application to pull configuration data from the specific repository in `application.yml`.

```yaml
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/ThomasVitale/config-repo
```

Then, enable the centralized configuration feature in Spring Boot with the `@EnableConfigServer` annotation.

```java
@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
  public static void main(String[] args) {
    SpringApplication.run(ConfigServerApplication.class, args);
  }
}
```

Finally, run the Config Server application:

```bash
$ ./gradlew bootRun
```

### 2.3 Using Config Server to configure Spring Boot microservices

> **Assignment**. Update Book Service with the Spring Cloud Config Client and configure it to fetch configuration
> from the Config Server.

Open the Book Service project and add a new dependency on `org.springframework.cloud:spring-cloud-starter-config`.

```groovy
ext {
  set('springCloudVersion', "2021.0.0-RC1")
}

dependencies {
  implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'
  implementation 'org.springframework.boot:spring-boot-starter-web'
  implementation 'org.springframework.cloud:spring-cloud-starter-config'
  implementation 'org.flywaydb:flyway-core'

  runtimeOnly 'org.postgresql:postgresql'

  testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

dependencyManagement {
  imports {
    mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
  }
}
```

Then, open the `application.yml` file and configure Book Service to fetch configuration data from Config Server.

```yaml
spring:
  config:
    import: "optional:configserver:"
  cloud:
    config:
      uri: http://localhost:8888
```

Re-run the Book Service application with the command:

```bash
$ ./gradlew bootRun
```

Check the application logs and verify Book Service is correctly fetching configuration from the Config Server
(`Fetching config from server at : http://localhost:8888`).

## Lab 3 - Service discovery and load balancing with Spring Cloud Netflix Eureka

In this lab, you'll set up a service discovery server with Spring Cloud Netflix Eureka and configure
Spring Boot microservices to use it instead of using IP addresses or hostnames.

### 3.1 Initializing a project for Eureka Server

> **Assignment**. Initialize a new Spring Boot project for Eureka Server including the following dependencies:
> Eureka Server. Then, configure application name and server port.

You can initialize a new Spring Boot project for **Eureka Server** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.6.0+
* _Name_: config-server
* _Packaging_: JAR
* _Java_: 17+

Choose the following dependencies:

* _Eureka Server_ provides service discovery functionality using the Netflix Eureka project.

Once you're done, open the project in your favourite IDE. Then, replace the autogenerated `application.properties`
file with `application.yml` and configure server port and application name.

```yaml
server:
  port: 8761

spring:
  application:
    name: eureka-server
```

### 3.2 Configuring service discovery (server)

> **Assignment**. Configure Eureka in standalone mode and enable the service discovery feature.
> Finally, run the Edge Server.

First of all, enable the service discovery feature in Spring Boot with the `@EnableEurekaServer` annotation.

```java
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
  public static void main(String[] args) {
    SpringApplication.run(EurekaServerApplication.class, args);
  }
}
```

Then, configure Eureka in standalone mode in `application.yml` by disabling the client functionality trying to
synchronize the service registry with other peer Eureka servers.

```yaml
eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
```

Finally, run the Eureka Server application:

```bash
$ ./gradlew bootRun
```

### 3.3 Configuring service discovery (client)

> **Assignment**. Configure both Book Service and Config Server to use Eureka to resolve service instance names.

The first step is adding a new dependency on `org.springframework.cloud:spring-cloud-starter-netflix-eureka-client`
in both the Book Service and Config Server projects.

Then, for both applications, update the `application.yml` to configure the communicatino with the Eureka Server.

```yaml
eureka:
  client:
    serviceUrl:
      defaultZone: ${EUREKA_SERVER_URL:http://localhost:8761/eureka/}
```

Furthermore, you can update Book Service to use Eureka to resolve the Config Server URL rather than
providing an hostname+port pair.

```yaml
spring:
  config:
    import: "optional:configserver:"
  cloud:
    config:
      discovery:
        enabled: true
        service-id: config-server
      uri: http://config-server
```

When you're done, re-run both Config Server and Book Service and verify everything works correctly.

