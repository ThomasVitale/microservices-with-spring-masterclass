# Microservices with Spring Boot and Spring Cloud (Masterclass)

Learn how to use Spring Boot to implement loosely-coupled, self-contained, resilient, secure, and scalable
applications. Youâ€™ll implement the main microservices patterns like API gateway, service discovery, load balancing,
and externalized configuration leveraging the power of Spring Cloud.

## Lab 1 - Building a microservice with Spring Boot

In this lab, you'll build a blocking microservice using Spring Boot. It will expose a REST API and persist data
in a PostgreSQL database.

### 1.1 Initializing a Spring Boot project

> **Assignment**. Initialize a new Spring Boot project for Book Service including the following dependencies:
> Spring Web, Spring Data JDBC, PostgreSQL Driver, Flyway Migration, Lombok. Then, configure application name
> and server port.

You can initialize a new Spring Boot project for **Book Service** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.5.1+
* _Name_: book-service
* _Packaging_: JAR
* _Java_: 11+

Choose the following dependencies:

* _Spring Web (`org.springframework.boot:spring-boot-starter-web`)_ provides the necessary libraries for building
  web applications with Spring MVC and includes Tomcat as the default embedded server.
* _Spring Data JDBC (`org.springframework.boot:spring-boot-starter-data-jdbc`)_ provides the necessary libraries
  to persist data in relational databases with JDBC using Spring Data in blocking applications.
* _PostgreSQL Driver (`org.postgresql:postgresql`)_ provides a JDBC driver that allows the application to connect
  to a PostgreSQL database.
* _Flyway Migration (`org.flywaydb:flyway-core`)_ provides the Flyway Java driver that allows the application
  to version control a database through migrations.
* _Lombok (`org.projectlombok:lombok`)_ is an annotation library that helps reducing boilerplate code. It's not
  required, but it'll help me showing you cleaner and more focused examples.

Once you're done, open the project in your favourite IDE. Then, replace the autogenerated `application.properties`
file with `application.yml` and configure server port and application name.

```yaml
server:
  port: 8001

spring:
  application:
    name: book-service
```

### 1.2 Domain entities and repositories with Spring Data JDBC

> **Assignment**. Implement the domain classes for Book Service: `Book` and `BookRepository`.
> Then configure the integration of Spring Boot with a PostgreSQL instance and initialize the schema
> with a Flyway migration.

The Book Service application will let you manage books for a bookshop. First of all, create a new
`domain` package in the Book Service project. Then, define a `Book` class to model the domain entity.

```java
@Data
public class Book {

	@Id
	private Long id;
	private String isbn;
	private String title;

}
```

* `@Data` is a Lombok annotation to generate boilerplate code for the class, such as getters and setters.
* `@Id` is a Spring Data annotation to mark the identifier (primary key) of the domain entity.

Next, define a `BookRepository` interface to provide access to Book data from the database.

```java
public interface BookRepository extends CrudRepository<Book,Long> {
	Optional<Book> findByIsbn(String isbn);
	void deleteByIsbn(String isbn);
}
```

Then, configure a `DataSource` to integrate the application with a PostgreSQL instance.
In `src/main/resources/application.yml`, add the following configuration.

```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/bookdb
    username: admin
    password: admin
```

Finally, create a Flyway migration to initialize the schema for the `Book` domain entity.
Write the SQL query to initialize the schema in `src/main/resources/db/migration/V1__Initial_schema.sql`.

```sql
CREATE TABLE book (
    id                  BIGSERIAL PRIMARY KEY NOT NULL,
    isbn                varchar(255) UNIQUE NOT NULL,
    title               varchar(255) NOT NULL
);
```

### 1.3 Run PostgreSQL as a Docker container

> **Assignment**. Use Docker Compose to define and run a PostgreSQL container called `postgres-book`.

Create a `docker-compose.yml` file and define a service to run a PostgreSQL database for Book Service.

```yaml
version: "3.8"
services:
  postgres-book:
    image: "postgres:latest"
    container_name: "postgres-book"
    ports:
      - 5432:5432
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=admin
      - POSTGRES_DB=bookdb
```

Then, open a Terminal window, navigate to the folder where your Docker Compose file is located,
and run run PostgreSQL:

```bash
$ docker-compose up -d postgres-book
```

### 1.4 RESTful microservices with Spring Web

> **Assignment**. Implement a `BookController` class to expose a REST API to create and read books.

| Endpoint	      | Method   | Req. body  | Status | Resp. body     | Description    		   	     |
|:---------------:|:--------:|:----------:|:------:|:--------------:|:-------------------------------|
| `/books`        | `GET`    |            | 200    | Iterable<Book> | Get all the books in the catalog. |
| `/books/{isbn}` | `GET`    |            | 200    | Book           | Get the book with the given ISBN. |
| `/books`        | `POST`   | Book       | 201    | Book           | Add a new book to the catalog. |

First, define a new `web` package. Then, create a `BookController` class inside with handlers for
GET and POST requests as described in the table above.

```java
@RestController
@RequestMapping("books")
@RequiredArgsConstructor
public class BookController {
	private final BookRepository bookRepository;

	@GetMapping
	public Iterable<Book> getAllBooks() {
		return bookRepository.findAll();
	}

	@GetMapping("{isbn}")
	public Optional<Book> getBookByIsbn(@PathVariable("isbn") String isbn) {
		return bookRepository.findByIsbn(isbn);
	}

	@PostMapping
	@ResponseStatus(HttpStatus.CREATED)
	public Book addBook(@RequestBody Book book) {
		return bookRepository.save(book);
	}
}
```

The controller makes use of a few annotations:
* `@RestController` is a stereotype annotation marking a class as a Spring component and as a source of handlers
  for REST endpoints.
* `@RequestMapping` identifies the root path mapping URI for which the class provides handlers ("/books").
* `@GetMapping` maps HTTP GET requests onto the specific handler method.
* `@PostMapping` maps HTTP POST requests onto the specific handler method.
* `@ResponseStatus` returns a specific HTTP status if the request is successful.
* `@PathVariable` binds a method parameter to a URI template variable ({isbn}).
* `@RequestBody` binds a method parameter to the body of a web request.
* `@RequiredArgsConstructor` generates a constructor with BookRepository, that gets autowired through construction
  injection.

### 1.5 Running a Spring Boot microservice

> **Assignment**. Run the Book Service application and test its behaviour.

Run the Book Service application with the command:

```bash
$ ./gradlew bootRun
```

You can test the application with curl or [httpie](https://httpie.io).

```bash
$ http POST :8001/books isbn="1234567890" title="The Lord of the Rings"
```

```bash
$ http :8001/books"
```

## Lab 2 - Centralized configuration with Spring Cloud Config

In this lab, you'll set up a configuration server with Spring Cloud Config and use it to provide configuration
to Spring Boot microservices.

### 2.1 Initializing a project for Config Server

> **Assignment**. Initialize a new Spring Boot project for Config Server including the following dependencies:
> Config Server. Then, configure application name and server port.

You can initialize a new Spring Boot project for **Config Server** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.5.1+
* _Name_: config-server
* _Packaging_: JAR
* _Java_: 11+

Choose the following dependencies:

* _Config Server_ provides central configuration management via Git, JDBC, Vault, or other sources.

Once you're done, open the project in your favourite IDE. Then, replace the autogenerated `application.properties`
file with `application.yml` and configure server port and application name.

```yaml
server:
  port: 8888

spring:
  application:
    name: config-server
```

### 2.2 Defining a configuration repository

> **Assignment**. Define a Git repository to host configuration data, then update the Config Server application
> to use the repository and to enable the centralized configuration feature. Finally, run the Config Server.

You can define you own configuration repository in Git or use https://github.com/ThomasVitale/config-repo directly.
Either way, configure the application to pull configuration data from the specific repository in `application.yml`.

```yaml
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/ThomasVitale/config-repo
```

Then, enable the centralized configuration feature in Spring Boot with the `@EnableConfigServer` annotation.

```java
@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
  public static void main(String[] args) {
    SpringApplication.run(ConfigServerApplication.class, args);
  }
}
```

Finally, run the Config Server application:

```bash
$ ./gradlew bootRun
```

### 2.3 Using Config Server to configure Spring Boot microservices

> **Assignment**. Update Book Service with the Spring Cloud Config Client and configure it to fetch configuration
> from the Config Server.

Open the Book Service project and add a new dependency on `org.springframework.cloud:spring-cloud-starter-config`.

```groovy
ext {
  set('springCloudVersion', "2020.0.4-SNAPSHOT")
}

dependencies {
  implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'
  implementation 'org.springframework.boot:spring-boot-starter-web'
  implementation 'org.springframework.cloud:spring-cloud-starter-config'
  implementation 'org.flywaydb:flyway-core'

  compileOnly 'org.projectlombok:lombok'
  runtimeOnly 'org.postgresql:postgresql'
  annotationProcessor 'org.projectlombok:lombok'

  testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

dependencyManagement {
  imports {
    mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
  }
}
```

Then, open the `application.yml` file and configure Book Service to fetch configuration data from Config Server.

```yaml
spring:
  config:
    import: "optional:configserver:"
  cloud:
    config:
      uri: http://localhost:8888
```

Re-run the Book Service application with the command:

```bash
$ ./gradlew bootRun
```

Check the application logs and verify Book Service is correctly fetching configuration from the Config Server
(`Fetching config from server at : http://localhost:8888`).
